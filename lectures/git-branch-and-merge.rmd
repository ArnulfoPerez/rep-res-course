---
title: Branch and Merge
author: "Eric C. Anderson"
output:
  html_document:
    toc: yes
  bookdown::html_chapter:
    toc: no
layout: default_with_disqus
---

# Branching and Merging {#branch-and-merge}

## What the heck is a branch? {#whats-a-branch}

* Note that the motto for git is "_local branching on the cheap_," so branches must be important
![branching on the cheap](diagrams/git.png)

* A branch is a "lightweight pointer to a commit"...What?
* Let's refresh our memory on what commits, trees, and blobs are.


### Data structure within the .git folder
_note: diagrams used here are from Scott Chacon's [ProGit](http://git-scm.com/book/en/) book and are used under the
[CC Noncommercial 3.0 Attribution license](https://creativecommons.org/licenses/by-nc/3.0/us/).
I took them from [here](https://github.com/progit/progit/tree/master/figures)_
![A commit](diagrams/18333fig0301-tn.png)

* Contents of (different versions of) files in your repository are stored in blobs
* (Sub)directory structure (locations of files in your repository) stored in trees
    + The tree and the blobs referenced in it constitute the "snapshot" of the repository.
* Commits: for a given snapshot, points to a tree, has a comment, an author, a committer, __and__
    + Unless it is the first commit, it has a pointer to a parent.
    
---

---

### A chain or sequence of commits 

![A commit](diagrams/18333fig0302-tn.png)

* The arrows between commits point to parents.  Thus the later commits
are on the right, and the earlier commits on the left.
* This is critical: every commit knows where it came from (the previous commit).
* Just as a genealogy (i.e., links to parents) gives your family history, so too do the commits
_and the links from each commit to its parent(s)_ constitute the __version history__ of your
repository.

---

---

### Easy access to commits

* Commits would not be useful if they were just stored in the .git directory of your repository with no way to access them.
* Branches are how you access commits so that you can:
    + Check them out (be able to access their contents)
    + Modify the contents and make a new commit
* They are "lightweight" in that they don't take up much space (each branch is just a file with the sha-1 hash of a commit in it)
* Upon initialization, every repository gets a branch called _master_

![A commit](diagrams/18333fig0303-tn.png)

* It is customary to let _master_ be where your _stable_, deployable code is kept.

---

---


### What it means to be _on a branch_

* If you are on a branch, (say _master_ for the sake of argument) that means that
    1. There is a commit pointed to by _master_.  (Let's say it is 8e334ab3)
    2. Any changes you make, __when staged and committed__ will create a new commit
    whose parent (in this case) is 8e334ab3.
* In git, if you are on a branch, then the HEAD points to that branch.

![A commit](diagrams/18333fig0305-tn.png)
    
* Hey, there are two branches pointing to the same commit!
    + That is just fine.  You can have as many branches as you want pointing to a commit.
    + Question.  If changes are committed now, what happens to the two branches? This is crucial...



    
## Creating and using branches {#creating-and-using-branches}

### Creating a branch called "testing"

* In the shell, when you type
    ```{r, eval=FALSE}
    git branch some-name
    ```
git will make a new branch for you named `some-name`.
* __It will point to whatever commit HEAD currently points to.__ (i.e. the branch that you 
are currently on.)
* Let's do this together.
    1. Create a new rstudio project with version control:
        + File -> New Project -> New Directory -> Empty Project
        + Let the directory name be `branchy` and make it a subdirectory of Desktop.
        + _Important:_ check the box to "create a git repository"
    2. At this point there are no commits. Stage `.gitignore` and `branchy.Rproj` and commit them.
    3. Look at the "diff" / History window, and notice that there is one commit and _HEAD_ and _master_
    are at it:
    ![rstudio git hist](diagrams/rs-git-hist-1.png)
    4. Let's "move _master_ forward" by making a new .Rmd file called `simple.Rmd` and committing it.
    Now our history looks like:
    ![rstudio git hist](diagrams/rs-git-hist-2.png)
    5. Now, let's make a new branch called `testing`.  In the shell (in the correct directory):
        ```{r, eval = FALSE}
        git branch testing
        ```
    Notice that RStudio's git-history shows us that HEAD, master, and testing, all now point to the same
    commit.  But the visual there doeesn't tell us which branch we are one (where HEAD is attached.)
        + No worries, upper right of the git pane tells us.
    

### Checking out a branch

* If we want to be _on a branch_ we need to "check that branch out". Either:
    ```{r, eval=FALSE}
    git checkout testing
    ```
in the shell, or use the dropdown in the upper right of the git pane.

### When git doesn't let you checkout a branch

## Merging branches {#merging-branches}

Note that merging creates a new commit!!
This is as it must and should be!


### Simplest case = Fast-forward merge

### Harder case, both branches in the merge have moved forward

* Git takes care of the difficulties here (finding the "merge base", etc.)

### Both branches change the same file

* Not a problem unless the same line in the file has been changed in the different branches being merged.

### Merge conflicts

### Resolving merge conflicts

### If we have time...
It is really fun to browse the history for Hadley's advanced R book.
